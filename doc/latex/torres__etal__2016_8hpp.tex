\hypertarget{torres__etal__2016_8hpp}{}\section{include/torres\+\_\+etal\+\_\+2016.hpp File Reference}
\label{torres__etal__2016_8hpp}\index{include/torres\+\_\+etal\+\_\+2016.\+hpp@{include/torres\+\_\+etal\+\_\+2016.\+hpp}}


Utility for computational geometry.  


{\ttfamily \#include $<$cgutil.\+hpp$>$}\\*
{\ttfamily \#include $<$algorithm$>$}\\*
{\ttfamily \#include $<$array$>$}\\*
{\ttfamily \#include $<$cmath$>$}\\*
{\ttfamily \#include $<$string$>$}\\*
{\ttfamily \#include $<$unordered\+\_\+map$>$}\\*
{\ttfamily \#include $<$vector$>$}\\*
{\ttfamily \#include $<$boost/range/adaptor/indexed.\+hpp$>$}\\*
{\ttfamily \#include $<$boost/range/adaptor/reversed.\+hpp$>$}\\*
{\ttfamily \#include $<$ros/ros.\+h$>$}\\*
{\ttfamily \#include $<$std\+\_\+msgs/\+Float64.\+h$>$}\\*
{\ttfamily \#include $<$geometry\+\_\+msgs/\+Point.\+h$>$}\\*
Include dependency graph for torres\+\_\+etal\+\_\+2016.\+hpp\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{torres__etal__2016_8hpp__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=326pt]{torres__etal__2016_8hpp__dep__incl}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{struct_direction}{Direction}
\begin{DoxyCompactList}\small\item\em Storage for line sweep direction. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{torres__etal__2016_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} = std\+::vector$<$ geometry\+\_\+msgs\+::\+Point $>$
\item 
using \hyperlink{torres__etal__2016_8hpp_a7634fe1379961a22350dbd7047b2e8c1}{Line\+Segment} = std\+::array$<$ geometry\+\_\+msgs\+::\+Point, 2 $>$
\item 
using \hyperlink{torres__etal__2016_8hpp_a1b95586556e66ecbe3e4c552548d1027}{Line\+Segment\+Vector} = std\+::vector$<$ \hyperlink{cgutil_8hpp_a7634fe1379961a22350dbd7047b2e8c1}{Line\+Segment} $>$
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{torres__etal__2016_8hpp_adc3d848b997fd331da7d3d405b6e3c36}{is\+Clock\+Wise} (const \hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \&path)
\begin{DoxyCompactList}\small\item\em Checks if given path is clockwise (the first turn made to the left) or not. \end{DoxyCompactList}\item 
\hyperlink{struct_direction}{Direction} \hyperlink{torres__etal__2016_8hpp_ac84e8199494b1bbdec441cf3cf5db0db}{identify\+Optimal\+Sweep\+Dir} (const \hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \&polygon)
\begin{DoxyCompactList}\small\item\em Calculates line sweep direction for given polygon. \end{DoxyCompactList}\item 
\hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \hyperlink{torres__etal__2016_8hpp_a0daa54859a24719e9ef5c4d957ad864f}{reshape\+Path} (const \hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \&path, double padding)
\begin{DoxyCompactList}\small\item\em Reshape given path. \end{DoxyCompactList}\item 
bool \hyperlink{torres__etal__2016_8hpp_a340e8ecb91a252b4343c57f01ace7130}{compute\+Convex\+Coverage} (const \hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \&polygon, double footprint\+Width, double horizontal\+Overwrap, const \hyperlink{struct_direction}{Direction} \&sweep\+Direction, \hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \&path)
\begin{DoxyCompactList}\small\item\em Compute coverage path for convex polygon. \end{DoxyCompactList}\item 
bool \hyperlink{torres__etal__2016_8hpp_a10cafc27ed2f11edf912c94e7f30107e}{compute\+Convex\+Coverage} (const \hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \&polygon, double footprint\+Width, double horizontal\+Overwrap, \hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \&path)
\begin{DoxyCompactList}\small\item\em Compute coverage path for convex polygon. \end{DoxyCompactList}\item 
double \hyperlink{torres__etal__2016_8hpp_a03113b9a489d4c5846eadfa4576ce7e3}{calculate\+Path\+Length} (const \hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \&path)
\begin{DoxyCompactList}\small\item\em Calculates length of path. \end{DoxyCompactList}\item 
\hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \hyperlink{torres__etal__2016_8hpp_a71b7a534df669e33077111195cb5cc4b}{compute\+C\+C\+W\+Path} (\hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} path)
\begin{DoxyCompactList}\small\item\em Return counter clock wise-\/ed path of given path. \end{DoxyCompactList}\item 
\hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \hyperlink{torres__etal__2016_8hpp_afa4eb774c5f34b95abf1e450602f9ada}{compute\+Opposite\+Path} (const \hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \&path)
\begin{DoxyCompactList}\small\item\em Return opposite path of given path. \end{DoxyCompactList}\item 
\hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \hyperlink{torres__etal__2016_8hpp_af347c57b74f9db063c89d01151933e29}{identify\+Optimal\+Alternative} (const \hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \&polygon, const \hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \&path, const geometry\+\_\+msgs\+::\+Point \&start, const geometry\+\_\+msgs\+::\+Point \&end)
\begin{DoxyCompactList}\small\item\em Identify optimal path from 4 coverage alternatives. \end{DoxyCompactList}\item 
\hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \hyperlink{torres__etal__2016_8hpp_a012334ffd93ffb76acb1a8d31984721e}{identify\+Optimal\+Alternative} (const \hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \&polygon, const \hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \&path, const geometry\+\_\+msgs\+::\+Point \&start)
\begin{DoxyCompactList}\small\item\em Identify optimal path from 4 coverage alternatives. \end{DoxyCompactList}\item 
bool \hyperlink{torres__etal__2016_8hpp_a7a55117d4e1bdfc6a402f62db41b5024}{find\+Second\+Optimal\+Path} (const \hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \&polygon, double footprint\+Width, double horizontal\+Overwrap, \hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \&path)
\begin{DoxyCompactList}\small\item\em Find second optimal path. \end{DoxyCompactList}\item 
bool \hyperlink{torres__etal__2016_8hpp_aee24dd72675dcde2c3ad1930e2cf4658}{is\+Adjacent} (const \hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \&polygon1, const \hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \&polygon2)
\begin{DoxyCompactList}\small\item\em Check if given two polygons are adjacent. \end{DoxyCompactList}\item 
\hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} \hyperlink{torres__etal__2016_8hpp_a20fa2d4d482ca06a8f9956491237699c}{compute\+Multiple\+Polygon\+Coverage} (std\+::vector$<$ \hyperlink{cgutil_8hpp_a23afdbfcb523553a73b329d7a91a7489}{Point\+Vector} $>$ sub\+Polygons, double footprint\+Width, double horizontal\+Overwrap, int adjacency\+Criteria=1)
\begin{DoxyCompactList}\small\item\em Compute coverage path for multiple convex polygons. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Utility for computational geometry. 

Header file for \hyperlink{torres__etal__2016_8cpp}{torres\+\_\+etal\+\_\+2016.\+cpp}.

\begin{DoxyAuthor}{Author}
Takaki Ueno 
\end{DoxyAuthor}


\subsection{Typedef Documentation}
\index{torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}!Line\+Segment@{Line\+Segment}}
\index{Line\+Segment@{Line\+Segment}!torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}}
\subsubsection[{\texorpdfstring{Line\+Segment}{LineSegment}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Line\+Segment} =  std\+::array$<$geometry\+\_\+msgs\+::\+Point, 2$>$}\hypertarget{torres__etal__2016_8hpp_a7634fe1379961a22350dbd7047b2e8c1}{}\label{torres__etal__2016_8hpp_a7634fe1379961a22350dbd7047b2e8c1}
\index{torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}!Line\+Segment\+Vector@{Line\+Segment\+Vector}}
\index{Line\+Segment\+Vector@{Line\+Segment\+Vector}!torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}}
\subsubsection[{\texorpdfstring{Line\+Segment\+Vector}{LineSegmentVector}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Line\+Segment\+Vector} =  std\+::vector$<${\bf Line\+Segment}$>$}\hypertarget{torres__etal__2016_8hpp_a1b95586556e66ecbe3e4c552548d1027}{}\label{torres__etal__2016_8hpp_a1b95586556e66ecbe3e4c552548d1027}
\index{torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}!Point\+Vector@{Point\+Vector}}
\index{Point\+Vector@{Point\+Vector}!torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}}
\subsubsection[{\texorpdfstring{Point\+Vector}{PointVector}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf Point\+Vector} =  std\+::vector$<$geometry\+\_\+msgs\+::\+Point$>$}\hypertarget{torres__etal__2016_8hpp_a23afdbfcb523553a73b329d7a91a7489}{}\label{torres__etal__2016_8hpp_a23afdbfcb523553a73b329d7a91a7489}


\subsection{Function Documentation}
\index{torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}!calculate\+Path\+Length@{calculate\+Path\+Length}}
\index{calculate\+Path\+Length@{calculate\+Path\+Length}!torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}}
\subsubsection[{\texorpdfstring{calculate\+Path\+Length(const Point\+Vector \&path)}{calculatePathLength(const PointVector &path)}}]{\setlength{\rightskip}{0pt plus 5cm}double calculate\+Path\+Length (
\begin{DoxyParamCaption}
\item[{const {\bf Point\+Vector} \&}]{path}
\end{DoxyParamCaption}
)}\hypertarget{torres__etal__2016_8hpp_a03113b9a489d4c5846eadfa4576ce7e3}{}\label{torres__etal__2016_8hpp_a03113b9a489d4c5846eadfa4576ce7e3}


Calculates length of path. 


\begin{DoxyParams}{Parameters}
{\em path} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
double Length of path 
\end{DoxyReturn}
\index{torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}!compute\+C\+C\+W\+Path@{compute\+C\+C\+W\+Path}}
\index{compute\+C\+C\+W\+Path@{compute\+C\+C\+W\+Path}!torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}}
\subsubsection[{\texorpdfstring{compute\+C\+C\+W\+Path(\+Point\+Vector path)}{computeCCWPath(PointVector path)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point\+Vector} compute\+C\+C\+W\+Path (
\begin{DoxyParamCaption}
\item[{{\bf Point\+Vector}}]{path}
\end{DoxyParamCaption}
)}\hypertarget{torres__etal__2016_8hpp_a71b7a534df669e33077111195cb5cc4b}{}\label{torres__etal__2016_8hpp_a71b7a534df669e33077111195cb5cc4b}


Return counter clock wise-\/ed path of given path. 


\begin{DoxyParams}{Parameters}
{\em path} & Clockwise path \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Point\+Vector Counter clock wise version of given path 
\end{DoxyReturn}
\index{torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}!compute\+Convex\+Coverage@{compute\+Convex\+Coverage}}
\index{compute\+Convex\+Coverage@{compute\+Convex\+Coverage}!torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}}
\subsubsection[{\texorpdfstring{compute\+Convex\+Coverage(const Point\+Vector \&polygon, double footprint\+Width, double horizontal\+Overwrap, const Direction \&sweep\+Direction, Point\+Vector \&path)}{computeConvexCoverage(const PointVector &polygon, double footprintWidth, double horizontalOverwrap, const Direction &sweepDirection, PointVector &path)}}]{\setlength{\rightskip}{0pt plus 5cm}bool compute\+Convex\+Coverage (
\begin{DoxyParamCaption}
\item[{const {\bf Point\+Vector} \&}]{polygon, }
\item[{double}]{footprint\+Width, }
\item[{double}]{horizontal\+Overwrap, }
\item[{const {\bf Direction} \&}]{sweep\+Direction, }
\item[{{\bf Point\+Vector} \&}]{path}
\end{DoxyParamCaption}
)}\hypertarget{torres__etal__2016_8hpp_a340e8ecb91a252b4343c57f01ace7130}{}\label{torres__etal__2016_8hpp_a340e8ecb91a252b4343c57f01ace7130}


Compute coverage path for convex polygon. 


\begin{DoxyParams}{Parameters}
{\em polygon} & Coverage path is calculated on this region \\
\hline
{\em footprint\+Width} & Width of the area taken by one sweep \\
\hline
{\em horizontal\+Overwrap} & Horizontal overwrap of each sweep \\
\hline
{\em sweep\+Direction} & \\
\hline
{\em path} & Path of coverage path \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True if path does not intersect with polygon 
\end{DoxyReturn}
\index{torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}!compute\+Convex\+Coverage@{compute\+Convex\+Coverage}}
\index{compute\+Convex\+Coverage@{compute\+Convex\+Coverage}!torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}}
\subsubsection[{\texorpdfstring{compute\+Convex\+Coverage(const Point\+Vector \&polygon, double footprint\+Width, double horizontal\+Overwrap, Point\+Vector \&path)}{computeConvexCoverage(const PointVector &polygon, double footprintWidth, double horizontalOverwrap, PointVector &path)}}]{\setlength{\rightskip}{0pt plus 5cm}bool compute\+Convex\+Coverage (
\begin{DoxyParamCaption}
\item[{const {\bf Point\+Vector} \&}]{polygon, }
\item[{double}]{footprint\+Width, }
\item[{double}]{horizontal\+Overwrap, }
\item[{{\bf Point\+Vector} \&}]{path}
\end{DoxyParamCaption}
)}\hypertarget{torres__etal__2016_8hpp_a10cafc27ed2f11edf912c94e7f30107e}{}\label{torres__etal__2016_8hpp_a10cafc27ed2f11edf912c94e7f30107e}


Compute coverage path for convex polygon. 


\begin{DoxyParams}{Parameters}
{\em polygon} & Coverage path is calculated on this region \\
\hline
{\em footprint\+Width} & Width of the area taken by one sweep \\
\hline
{\em horizontal\+Overwrap} & Horizontal overwrap of each sweep \\
\hline
{\em path} & Path of coverage path \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True if path does not intersect with polygon 
\end{DoxyReturn}
\index{torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}!compute\+Multiple\+Polygon\+Coverage@{compute\+Multiple\+Polygon\+Coverage}}
\index{compute\+Multiple\+Polygon\+Coverage@{compute\+Multiple\+Polygon\+Coverage}!torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}}
\subsubsection[{\texorpdfstring{compute\+Multiple\+Polygon\+Coverage(std\+::vector$<$ Point\+Vector $>$ sub\+Polygons, double footprint\+Width, double horizontal\+Overwrap, int adjacency\+Criteria=1)}{computeMultiplePolygonCoverage(std::vector< PointVector > subPolygons, double footprintWidth, double horizontalOverwrap, int adjacencyCriteria=1)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point\+Vector} compute\+Multiple\+Polygon\+Coverage (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ {\bf Point\+Vector} $>$}]{sub\+Polygons, }
\item[{double}]{footprint\+Width, }
\item[{double}]{horizontal\+Overwrap, }
\item[{int}]{adjacency\+Criteria = {\ttfamily 1}}
\end{DoxyParamCaption}
)}\hypertarget{torres__etal__2016_8hpp_a20fa2d4d482ca06a8f9956491237699c}{}\label{torres__etal__2016_8hpp_a20fa2d4d482ca06a8f9956491237699c}


Compute coverage path for multiple convex polygons. 


\begin{DoxyParams}{Parameters}
{\em sub\+Polygons} & \\
\hline
{\em footprint\+Width} & \\
\hline
{\em horizontal\+Overwrap} & \\
\hline
{\em adjacency\+Criteria} & Ignore paths which have less adjacent polygons than this number \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Point\+Vector Computed Path  See section 6.\+2 of torres et al. 2016 for the detail 
\end{DoxyReturn}
\index{torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}!compute\+Opposite\+Path@{compute\+Opposite\+Path}}
\index{compute\+Opposite\+Path@{compute\+Opposite\+Path}!torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}}
\subsubsection[{\texorpdfstring{compute\+Opposite\+Path(const Point\+Vector \&path)}{computeOppositePath(const PointVector &path)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point\+Vector} compute\+Opposite\+Path (
\begin{DoxyParamCaption}
\item[{const {\bf Point\+Vector} \&}]{path}
\end{DoxyParamCaption}
)}\hypertarget{torres__etal__2016_8hpp_afa4eb774c5f34b95abf1e450602f9ada}{}\label{torres__etal__2016_8hpp_afa4eb774c5f34b95abf1e450602f9ada}


Return opposite path of given path. 


\begin{DoxyParams}{Parameters}
{\em path} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Point\+Vector Path with points of reversed order of given path 
\end{DoxyReturn}
\index{torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}!find\+Second\+Optimal\+Path@{find\+Second\+Optimal\+Path}}
\index{find\+Second\+Optimal\+Path@{find\+Second\+Optimal\+Path}!torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}}
\subsubsection[{\texorpdfstring{find\+Second\+Optimal\+Path(const Point\+Vector \&polygon, double footprint\+Width, double horizontal\+Overwrap, Point\+Vector \&path)}{findSecondOptimalPath(const PointVector &polygon, double footprintWidth, double horizontalOverwrap, PointVector &path)}}]{\setlength{\rightskip}{0pt plus 5cm}bool find\+Second\+Optimal\+Path (
\begin{DoxyParamCaption}
\item[{const {\bf Point\+Vector} \&}]{polygon, }
\item[{double}]{footprint\+Width, }
\item[{double}]{horizontal\+Overwrap, }
\item[{{\bf Point\+Vector} \&}]{path}
\end{DoxyParamCaption}
)}\hypertarget{torres__etal__2016_8hpp_a7a55117d4e1bdfc6a402f62db41b5024}{}\label{torres__etal__2016_8hpp_a7a55117d4e1bdfc6a402f62db41b5024}


Find second optimal path. 


\begin{DoxyParams}{Parameters}
{\em polygon} & \\
\hline
{\em footprint\+Width} & \\
\hline
{\em horizontal\+Overwrap} & \\
\hline
{\em path} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True if second optimal path exists 
\end{DoxyReturn}
\index{torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}!identify\+Optimal\+Alternative@{identify\+Optimal\+Alternative}}
\index{identify\+Optimal\+Alternative@{identify\+Optimal\+Alternative}!torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}}
\subsubsection[{\texorpdfstring{identify\+Optimal\+Alternative(const Point\+Vector \&polygon, const Point\+Vector \&path, const geometry\+\_\+msgs\+::\+Point \&start, const geometry\+\_\+msgs\+::\+Point \&end)}{identifyOptimalAlternative(const PointVector &polygon, const PointVector &path, const geometry_msgs::Point &start, const geometry_msgs::Point &end)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point\+Vector} identify\+Optimal\+Alternative (
\begin{DoxyParamCaption}
\item[{const {\bf Point\+Vector} \&}]{polygon, }
\item[{const {\bf Point\+Vector} \&}]{path, }
\item[{const geometry\+\_\+msgs\+::\+Point \&}]{start, }
\item[{const geometry\+\_\+msgs\+::\+Point \&}]{end}
\end{DoxyParamCaption}
)}\hypertarget{torres__etal__2016_8hpp_af347c57b74f9db063c89d01151933e29}{}\label{torres__etal__2016_8hpp_af347c57b74f9db063c89d01151933e29}


Identify optimal path from 4 coverage alternatives. 


\begin{DoxyParams}{Parameters}
{\em polygon} & \\
\hline
{\em path} & \\
\hline
{\em start} & Start point \\
\hline
{\em end} & End point \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Point\+Vector Optimal path that minimizes the length of path  The naming of the following variable follows torres et al. 2016 
\end{DoxyReturn}
\index{torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}!identify\+Optimal\+Alternative@{identify\+Optimal\+Alternative}}
\index{identify\+Optimal\+Alternative@{identify\+Optimal\+Alternative}!torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}}
\subsubsection[{\texorpdfstring{identify\+Optimal\+Alternative(const Point\+Vector \&polygon, const Point\+Vector \&path, const geometry\+\_\+msgs\+::\+Point \&start)}{identifyOptimalAlternative(const PointVector &polygon, const PointVector &path, const geometry_msgs::Point &start)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point\+Vector} identify\+Optimal\+Alternative (
\begin{DoxyParamCaption}
\item[{const {\bf Point\+Vector} \&}]{polygon, }
\item[{const {\bf Point\+Vector} \&}]{path, }
\item[{const geometry\+\_\+msgs\+::\+Point \&}]{start}
\end{DoxyParamCaption}
)}\hypertarget{torres__etal__2016_8hpp_a012334ffd93ffb76acb1a8d31984721e}{}\label{torres__etal__2016_8hpp_a012334ffd93ffb76acb1a8d31984721e}


Identify optimal path from 4 coverage alternatives. 


\begin{DoxyParams}{Parameters}
{\em polygon} & \\
\hline
{\em path} & \\
\hline
{\em start} & Start point \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Point\+Vector Optimal path that minimizes the length of path  The naming of the following variable follows torres et al. 2016 
\end{DoxyReturn}
\index{torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}!identify\+Optimal\+Sweep\+Dir@{identify\+Optimal\+Sweep\+Dir}}
\index{identify\+Optimal\+Sweep\+Dir@{identify\+Optimal\+Sweep\+Dir}!torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}}
\subsubsection[{\texorpdfstring{identify\+Optimal\+Sweep\+Dir(const Point\+Vector \&polygon)}{identifyOptimalSweepDir(const PointVector &polygon)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Direction} identify\+Optimal\+Sweep\+Dir (
\begin{DoxyParamCaption}
\item[{const {\bf Point\+Vector} \&}]{polygon}
\end{DoxyParamCaption}
)}\hypertarget{torres__etal__2016_8hpp_ac84e8199494b1bbdec441cf3cf5db0db}{}\label{torres__etal__2016_8hpp_ac84e8199494b1bbdec441cf3cf5db0db}


Calculates line sweep direction for given polygon. 


\begin{DoxyParams}{Parameters}
{\em polygon} & Line sweep direction is calculated on this region \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
direction Struct containing edge and vertex 
\end{DoxyReturn}
\index{torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}!is\+Adjacent@{is\+Adjacent}}
\index{is\+Adjacent@{is\+Adjacent}!torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}}
\subsubsection[{\texorpdfstring{is\+Adjacent(const Point\+Vector \&polygon1, const Point\+Vector \&polygon2)}{isAdjacent(const PointVector &polygon1, const PointVector &polygon2)}}]{\setlength{\rightskip}{0pt plus 5cm}bool is\+Adjacent (
\begin{DoxyParamCaption}
\item[{const {\bf Point\+Vector} \&}]{polygon1, }
\item[{const {\bf Point\+Vector} \&}]{polygon2}
\end{DoxyParamCaption}
)}\hypertarget{torres__etal__2016_8hpp_aee24dd72675dcde2c3ad1930e2cf4658}{}\label{torres__etal__2016_8hpp_aee24dd72675dcde2c3ad1930e2cf4658}


Check if given two polygons are adjacent. 


\begin{DoxyParams}{Parameters}
{\em polygon1} & \\
\hline
{\em polygon2} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if given two polygons are adjacent 
\end{DoxyReturn}
\index{torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}!is\+Clock\+Wise@{is\+Clock\+Wise}}
\index{is\+Clock\+Wise@{is\+Clock\+Wise}!torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}}
\subsubsection[{\texorpdfstring{is\+Clock\+Wise(const Point\+Vector \&path)}{isClockWise(const PointVector &path)}}]{\setlength{\rightskip}{0pt plus 5cm}bool is\+Clock\+Wise (
\begin{DoxyParamCaption}
\item[{const {\bf Point\+Vector} \&}]{path}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{torres__etal__2016_8hpp_adc3d848b997fd331da7d3d405b6e3c36}{}\label{torres__etal__2016_8hpp_adc3d848b997fd331da7d3d405b6e3c36}


Checks if given path is clockwise (the first turn made to the left) or not. 


\begin{DoxyParams}{Parameters}
{\em path} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True if path is clockwise  the definition of \char`\"{}clockwise\char`\"{} is based on Fig.\+8 in Torres et al. 2016 
\end{DoxyReturn}
\index{torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}!reshape\+Path@{reshape\+Path}}
\index{reshape\+Path@{reshape\+Path}!torres\+\_\+etal\+\_\+2016.\+hpp@{torres\+\_\+etal\+\_\+2016.\+hpp}}
\subsubsection[{\texorpdfstring{reshape\+Path(const Point\+Vector \&path, double padding)}{reshapePath(const PointVector &path, double padding)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Point\+Vector} reshape\+Path (
\begin{DoxyParamCaption}
\item[{const {\bf Point\+Vector} \&}]{path, }
\item[{double}]{padding}
\end{DoxyParamCaption}
)}\hypertarget{torres__etal__2016_8hpp_a0daa54859a24719e9ef5c4d957ad864f}{}\label{torres__etal__2016_8hpp_a0daa54859a24719e9ef5c4d957ad864f}


Reshape given path. 


\begin{DoxyParams}{Parameters}
{\em path} & The sweep lines of path should be horizontal about x axis \\
\hline
{\em padding} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Point\+Vector  Reshape given path so that generated path becomes the sequence of \char`\"{}\+C\char`\"{} shapes and add padding 
\end{DoxyReturn}
